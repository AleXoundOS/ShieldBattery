import { List, Map, Record, Set } from 'immutable'
import { assertUnreachable } from '../../common/assert-unreachable'
import { EMAIL_VERIFICATION_ID, Notification, NotificationType } from '../../common/notifications'
import keyedReducer from '../reducers/keyed-reducer'

export interface NotificationRecordBase {
  /**
   * A string that is unique if the notification is unique. For locally-generated notifications
   * that should never show duplicates, this might be a constant string. For server-generated ones
   * that have multiple of the same type (e.g. chat notifications, party invites, etc.) these are
   * generated by the server.
   */
  id: string
  type: NotificationType
  read: boolean
  createdAt: number
}

export class EmailVerificationNotificationRecord
  extends Record({
    id: EMAIL_VERIFICATION_ID,
    type: NotificationType.EmailVerification as typeof NotificationType.EmailVerification,
    read: false,
    createdAt: 0,
  })
  implements NotificationRecordBase {}

export class PartyInviteNotificationRecord
  extends Record({
    id: '',
    type: NotificationType.PartyInvite as typeof NotificationType.PartyInvite,
    read: false,
    createdAt: 0,
    from: '',
    partyId: '',
  })
  implements NotificationRecordBase {}

export type NotificationRecord = EmailVerificationNotificationRecord | PartyInviteNotificationRecord

function toNotificationRecord(notification: Readonly<Notification>): NotificationRecord {
  switch (notification.type) {
    case NotificationType.EmailVerification:
      return new EmailVerificationNotificationRecord(notification)
    case NotificationType.PartyInvite:
      return new PartyInviteNotificationRecord(notification)
    default:
      return assertUnreachable(notification)
  }
}

export class NotificationState extends Record({
  map: Map<string, NotificationRecord>(),
  ids: List<string>(),
}) {}

export default keyedReducer(new NotificationState(), {
  ['@notifications/serverInit'](state, { payload: { notifications } }) {
    return state
      .update('map', m => m.merge(notifications.map(n => [n.id, toNotificationRecord(n)])))
      .update('ids', s => s.unshift(...notifications.map(n => n.id)))
  },

  ['@notifications/add'](state, { payload: { notification } }) {
    if (state.map.has(notification.id)) {
      return state
    }

    return state
      .update('map', m => m.set(notification.id, toNotificationRecord(notification)))
      .update('ids', s => s.push(notification.id))
  },

  ['@notifications/clearById'](state, { payload: { notificationIds } }) {
    const idsSet = state.ids.toSet()
    const notificationIdsSet = Set(notificationIds)

    return state
      .update('map', m => m.deleteAll(notificationIds))
      .set('ids', idsSet.subtract(notificationIdsSet).toList())
  },

  ['@notifications/clear'](state) {
    return state.set('map', Map()).set('ids', List())
  },

  ['@notifications/markRead'](state, { meta: { notificationIds }, error }) {
    if (error) {
      return state
    }

    let map = state.map
    for (const notificationId of notificationIds) {
      if (map.has(notificationId)) {
        map = map.setIn([notificationId, 'read'], true)
      }
    }
    return state.set('map', map)
  },
})
